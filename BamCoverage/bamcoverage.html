<!DOCTYPE html>
<html>
<head>
<script type="text/javascript" src="js/d3.min.js"></script>
<link href="css/redmond/jquery-ui-1.10.3.custom.css" rel="stylesheet">
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui-1.10.3.custom.js"></script>

<style>
    .gap-region {
        stroke: red;
        stroke-width: 2;
    }
    .lc-region {
        stroke: blue;
        stroke-width: 5;
    }
    .lq-region {
        stroke: #CCCCCC;
        stroke-width: 5;
    }
    .norm-region {
        stroke: black;
        stroke-width: 5;
    }

    .regiontext {
        font-size: 8pt;
    }
</style>

<script type="text/javascript">
var Region = function( name, color, strokewidth, dasharray ) {
    this.name = name;
    this.stroke = color;
    this.strokewidth = strokewidth;
    this.dasharray = dasharray;
};

var samples;
var svg;
var xScale; 
var ref;
var regionTypes = {
    'LowCoverage': new Region( 'LowCoverage', 'blue', 2, '' ),
    'LowQuality': new Region( 'LowQuality', '#CCCCCC', 5, '' ),
    'Gap': new Region( 'Gap', 'red', 2, '' ),
    'Normal': new Region( 'Normal', 'black', 5, '' )
};

var SampleList = function( samples ) {
    this.samples = samples;
    this.uRefs;

    /*
        Get only samples that have references for given reference
    */
    this.getSamplesForRef = function( refname ) {
        var samples = [];
        for( var sample in this.samples ) {
            if( refname in this.samples[sample]['references'] ) {
                samples.push( this.samples[sample] );
            } 
        }
        return samples;
    };

    /*
        Build uniq_ref dictionary with list of samples for each unique ref
    */
    this.getUniqReferences = function() {
        // Only build the uRefs the first time this function is called
        if( typeof( this.uRefs ) == 'undefined' ) {
            this.uRefs = {};
            for( var sample in this.samples ) {
                for( var ref in this.samples[sample]['references'] ) {
                    if( !(ref in this.uRefs) ) {
                        this.uRefs[ref] = []
                    }
                    this.uRefs[ref].push( this.samples[sample] )
                }
            }
        }
        return this.uRefs;
    };

    /*
        Return list of uniq references and their lengths
    */
    this.getReferences = function() {
        var refs = [];
        var urefs = this.getUniqReferences();
        for( var ref in urefs ) {
            var reflen = urefs[ref][0]['references'][ref]['reflen'];
            refs.push( [ref,reflen] );
        }
        return refs;
    };

    /*
        Return the reference length for a given reference
    */
    this.getRefLength = function( reference ) {
        var maxlen = 0
        var refs = this.getReferences();
        for( var i in refs ) {
            if( refs[i][0] == reference ) {
                return refs[i][1];
            }
        }
        return maxlen;
    };
};

var Coverage = function( samplelist, reference, hPadding, element ) {
    this.sl = samplelist;
    this.ref = reference;
    ref = reference;
    this.hPadding = 20;
    this.infoNode = 'infoNode';
    this.rootElement = element;
    this.w = "100%";
    this.h = "768";
    this.fontSize = 6;
    this.svgID = reference + '-graphic';

    d3.select( this.rootElement ).select( 'svg' ).remove();

    this.svg = d3.select( this.rootElement )
        .append( 'svg' )
        .attr( 'width', this.w )
        .attr( 'height', this.h )
        .attr( 'id', this.svgID )

    svg = this.svg;

    maxDomain = this.sl.getRefLength( ref );
    xScale = d3.scale.linear()
        .domain( [0, maxDomain] )
        .range( [10, '100%'] );


    this.init = function () {
        this.makeGroups();
        this.applyXlabels();
    }

    this.applyXlabels = function( ) {
        var xticks = this.svg.append( "g" )
            .attr( "id", "xticks" )

        // Draw the vertical lines every 200 positions
        xticks.selectAll( "line" )
            .data( d3.range( 0, maxDomain, 200 ) )
            .enter()
            .append( "line" )
            .attr( "id", function(d,i){ return 'xtick-' + i; } )
            .attr( "x1", function(d,i){ return xScale(d); } )
            .attr( "x2", function(d,i){ return xScale(d); } )
            .attr( "y1", 0 )
            .attr( "y2", (percentToFloat(this.h)-5) + '%' )
            .attr( "stroke", "black" )
            .attr( "stroke-width", 0.25 );

        // Label each line
        xticks.selectAll( "text" )
            .data( d3.range( 0, maxDomain, 200 ) )
            .enter()
            .append( "text" )
            .attr( "x", function(d,i){
                    var m = String(d).length / 2 * 10 + 10;
                    return xScale(d-m); 
                })
            .attr( "y", this.h )
            .attr( "font-size", 8 )
            .text( function(d,i){ return d; } );

        // Draw a vertical line to show the end of the reference
        xticks.append( "line" )
            .attr( "x1", xScale( maxDomain ) )
            .attr( "x2", xScale( maxDomain ) )
            .attr( "y1", 0 )
            .attr( "y2", (percentToFloat(this.h)-5) + '%' )
            .attr( "stroke", "purple" )
            .attr( "stroke-width", 0.75 )

        // Label the end of reference line
        xticks.append( "text" )
            .attr( "y", this.h )
            .attr( "x", xScale( maxDomain - (String(maxDomain).length / 2 * 10 + 10) ) )
            .attr( "font-size", 9 )
            .text( maxDomain )

    };

    /*
        Adds all of the samples to the svg
    */
    this.makeGroups = function( ) {
        // Add g path element to svg for every sample
        var groups = this.svg.selectAll( "g" )
            .data( this.sl.getSamplesForRef( ref ) )
            .enter()
            .append('g')
            .attr( 'id', function(d,i){ return d.name; } )
            .classed( 'sample', 1 )

        // Add sample names to left side of graphic
        var samplelabels = groups.append( 'text' )
            .attr( 'size', this.fontSize )
            .attr( 'x', 0 )
            .attr( 'y', function(d,i){ return (i+1)*20; } )
            .classed( 'sample-name', 1 )
            .text( function(d) { return d.name; } )

        // Add the regions as lines to the graphic
        var lines = groups.each( function(d,sampleno) {
            var curE = d3.select(this)
                .selectAll( 'line' )
                .data( function(){ return d.references[ref]['regions']; } )
                .enter()
                .append( 'line' )
                .attr("id", function(d,i) {
                        return sampleno + '-' + d[0] + '-' + d[1];
                    })
                .attr("x1", function(d,i) {
                        return xScale(d[0]);
                    })
                .attr("x2", function(d,i) {
                        return xScale(d[1]);
                    })
                .attr("y1", function(d,i) {
                        return (sampleno+1) * 20 - 5;
                    })
                .attr("y2", function(d,i) {
                        return (sampleno+1) * 20 - 5;
                    })
                .each( function(d,i){
                    d3.select(this)
                        .attr( 'stroke', function(d){ return regionTypes[d[2]].stroke;} )
                        .attr( 'stroke-width', function(d){ return regionTypes[d[2]].strokewidth;} )
                        .attr( 'rstart', function(d){ return d[0]; } )
                        .attr( 'rend', function(d){ return d[1]; } )
                        .attr( 'rtype', function(d){ return d[2]; } );
                });
        });
        
        // Make all the lines selectable
        $(this.rootElement).selectable({
            filter: 'line',
            // Changes lines as they are selected
            selecting: function(e,ui){
                toggleLineSelected(ui.selecting);
            },
            // Changes lines back when regions are unselected
            unselecting: function(e,ui){
                toggleLineSelected(ui.unselecting);
            },
            start: function(e,ui){
                selectedRegions = {};
                console.log( "Start" );
            },
            stop: function(e,ui){
                console.log( "Stop" );
                console.log( selectedRegions );
                d = [];
                var minR = 999999;
                var maxR = 0;
                for( var x in selectedRegions ) {
                    var sr = selectedRegions[x];
                    d.push( sr );
                    var rStart = parseInt( sr.context.getAttribute('rstart') );
                    var rEnd = parseInt( sr.context.getAttribute('rend') );
                    if( rStart < minR ) {
                        minR = rStart;
                    }
                    if( rEnd > maxR ) {
                        maxR = rEnd;
                    }
                }
                if( d.length > 0 ) {
                    d3.select('#regionsContainer')
                        .append('ul')
                        .text( minR + ' -> ' + maxR )
                        .selectAll('li')
                        .data( d )
                        .enter()
                        .append('li')
                        .classed( 'regiontext', 1 )
                        .attr( 'id', function(d){return 'selected-'+d.context.id;} )
                        .text(function(d){return d.context.id;})
                }
            }
        });
    }
};
var line;
var selectedRegions = {};

/*
    Toggle a given lineElement so that it is not selected anymore
*/
function toggleLineOff( lineElement ){
    d3.select(lineElement)
        .attr( 'selected', 'false' )
        .transition()
        .attr( 'stroke-width', regionTypes[rtype].strokewidth );
    delete selectedRegions[lineElement.id];
}

/*
    Toggle a given lineElement so that it is selected
*/
function toggleLineOn( lineElement ){
    d3.select(lineElement)
        .attr( 'selected', 'true' )
        .transition()
        .attr( 'stroke-width', 15 );
    selectedRegions[lineElement.id] = $(lineElement);
}

function toggleLineSelected( lineElement ){
    rtype = lineElement.getAttribute('rtype');
    // Only apply transitions to Normal region lines
    if( rtype && rtype != 'Normal' ) {
        var isSelected = lineElement.getAttribute('selected') == 'true';
        if( isSelected ){
            toggleLineOff( lineElement );
        } else {
            toggleLineOn( lineElement );
        }
    }
}

/*
    Displays information about regions in the
    #regionExplorer container
*/
function exploreRegion( svgLineElement ) {
}

function init( pathToJson ) {
    d3.json( pathToJson, function(error, json){
        if( error ) {
            alert( "Error loading json" );
        }
        samples = json;
        setReference();
        createTabs();
        createRegionExplorer();
     });
    $(window).resize( function() {
        setSampleListPos();
    });
}

function setReference( referenceName, container ) {
    sl = new SampleList( samples );
    cov = new Coverage( sl, referenceName, 5, container );
    cov.init();
    /* Should be some sort of dialogue here */
    d3.select('#regionsContainer')
        .select('ul')
        .remove()
}

/*
    Creates the side panel that will list all of the selected regions
    that have been selected for resequencing
*/
function createRegionExplorer( ) {

    // Create the div and style it
    var regionExplorer = d3.select('body')
        .append('div')
        .attr( 'id', 'regionExplorer' )

    $('#regionExplorer').addClass( 'ui-widget' );
    $('#regionExplorer').addClass( 'ui-widget-content' );


    var ss = $('#regionExplorer');
    setSampleListPos();
    ss.addClass( 'ui-corner-all' );

    regionExplorer.append( 'div' )
        .attr( 'id', 'selectedRegionsTitle' )
        .style( 'text-align', 'center' )
        .text( "Region Explorer" )
    $('#selectedRegionsTitle').addClass( 'ui-widget-header' );

    regionExplorer.append( 'div' )
        .attr( 'id', 'regionsContainer' )
        .style( 'height', '100%' )
}

function setSampleListPos() {
    var ss = $('#regionExplorer');
    var winWidth = $('body').width();
    var tabWidth = $('#tabContainer').outerWidth();
    var tabHeight = $('#tabContainer').outerHeight();
    var myWidth = winWidth - tabWidth;

    ss.position({
        my: 'left top',
        at: 'right top',
        of: '#tabContainer'
    });

    ss.height( (tabHeight-2) + 'px' );
    ss.width( myWidth );
}

var tabs;
var clickedTab;
var clickedPanel;
/*
    Creates the main tab panel and all of the tabs populated with each unique
    reference in the json file
*/
function createTabs( ) {
    var references = sl.getReferences();
    // Create tabContainer div
    d3.select('body')
        .append( 'div' )
        .attr( 'id', 'tabContainer' )
        .style( 'width', '90%' )

    // Create the tabs
    d3.select('#tabContainer')
        .append( 'ul' )
        .attr( 'id', 'tabs' )
        .selectAll('li')
        .data( references )
        .enter()
        .append( 'li' )
        .attr( 'id', function(d){return d[0]} )
        .append( 'a' )
        .property( 'href', function(d,i){return '#tabs-' + i;} )
        .style( 'font-size', '8pt' )
        .text( function(d){ return d[0]; } );

    // Create the panels
    d3.select('#tabContainer')
        .selectAll( 'div' )
        .data( references )
        .enter()
        .append( 'div' )
        .attr( 'id', function(d,i){return 'tabs-' + i;} )
        .attr( 'width', '100%' )
        .attr( 'height', '100%' )

    tabs = $( '#tabContainer' ).tabs({
        activate: function( event, ui ) {
            var refName = ui.newTab.attr('id');
            var panelId = '#' + ui.newPanel.attr('id');
            clickedTab = ui.newTab;
            clickedPanel = ui.newPanel;
            setReference( refName, panelId );
            setSampleListPos();
        }
    });
}

function percentToFloat( percentstr ) {
	return percentstr.replace( "%", "" );
}

</script>

</head>
<body onLoad="init('regions.json')" height='100%' width='100%'>
</body>
</html>
